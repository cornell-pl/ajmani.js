\documentclass[a4paper,10pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{fullpage}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{color}
\usepackage{mathpartir}

\newcommand{\finish}[1]{#1}
\newcommand{\comment}[1]{\finish{\textbf{\textcolor{red}{#1}}}}
\newcommand{\jnf}[1]{\finish{\textbf{\textcolor{blue}{[#1---JNF]}}}}
\newcommand{\raghu}[1]{\finish{\textbf{\textcolor{blue}{[#1---Raghu]}}}}

\newcommand{\defeq}{\ensuremath{\stackrel{\Delta}{=}}}
\newcommand{\Unit}{\ensuremath{\mathbf{Unit}}}

%opening
\title{}
\author{}

\begin{document}

\maketitle

\section{Edit lenses with modifiable complement, aka M-Edit Lenses}
An edit lens between modules X and Y is $\langle C, init_C, K, putr, putl \rangle$, where $C$ is the type of complement, and $K \subseteq X \times C \times Y$ is the consistency relation. \\
The type of $putr$, $dX \times C \to dY \times C$ can be expressed as the isomorphic type $(dX \times C \to dY, dX \to C \to C)$. Thus, we can view the $putr$ function as having two components; one that translates an edit on $X$ into an edit on $Y$ (using $X$-data from the complement), and another that updates the complement (its $X$-data and alignment data) with respect to the edit on $X$.

[NB: We can view data as being $X$-data, $Y$-data, shared data, or alignment data. By $X$-data, we mean data that is present \emph{solely} in $X$ and not in $Y$, and similarly $Y$-data. An example of alignment data is a mapping of indices between two lists. The collection of $X$-indices can be considered $X$-data (and similarly for $Y$), but the mapping itself depends on both. This isn't shared data as it is not data that is present in both $X$ and $Y$ separately. An alternative term for alignment data can be \emph{state}.]

For a symmetric lens, the complement represents the data that is not shared. In an edit lens, there may be no necessity to capture all this data. For example, if we consider a list-mapping edit lens where the updates are list reorderings, the complement could just be \Unit. 

Alternatively, let us compare symmetric and edit lenses between $A \times D$ and $A \times E$, where updates include a filter operation. The complement for the symmetric lens would be $D \times E$. 
The complement for the edit lens needs to be $A \times D \times E$; this is because we need to write the transformation $d(A \times D) \to C \to C$, and doing so requires access to the data in $A$. If the complement were just $D \times E$, an update $filter~on~(A=a)$ cannot be processed , as there is insufficient information to know which elements get filtered.
Thus, for a sufficiently rich set of updates, the complement often subsumes the entirety of the data in the two sources.
[This issue does not arise in Hofmann et. al.'s paper, as the monoids of edits they consider are not rich enough.]

Ideally, the complement update part of the $putr$ transformation would have the type $(dX, X) \to C \to C$. The changes to the $X$-related components of $C$ can be calcluated from the first argument, and the remainder of $C$ can be propagated from the second argument. 

The complement must contain all the alignment data, since it doesn't exist anywhere else. If the complement contains all the $X$-data, then the complement update part of $putr$ could have its type replaced with $(dX, Y) \to C \to C$, since the shared data is contained in both $X$ and $Y$. The reason for wanting to do this is that $Y$ may be materialized, while $X$ may not. 
In the case of schema evolution, we want to translate $V1$ updates to a $V2$ database, where $V2$ is materialized, and $V1$ is not.

Even if the complement contains sufficient information, there is still a problem that the lens may produce very large edits. For example, consider the case of a database update in which a column is deleted from a table. This has a corresponding edit lens with a $putr$ function of type $dA \times C \to dB \times C$. If we have an edit that deletes records depending on whether a predicate holds of the deleted column, this edit can not be directly translated to an edit on dB. This is because $B$ does not have the deleted column. Thus, we first need to apply a filter to the complement to discover which records will be deleted, and then embed this result in a $dB$ edit. This results in the size of the edit being proportional to the result of the filter, which can be the entire table in the worst case.

If we have replaced the complement update part of $putr$ with $(dX, Y) \to C \to C$, or more generally, $(dX, Y) \to dC$, then we can combine the two components of $putr$ as $dX \to d(Y \times C)$. This solves the problem of $putr$ producing a large edit, since the result of the computation on $C$ does not need to be embedded in the edit. Instead, the computation itself can be expressed in the edit and computed later.

\section{M-Edit lens}

\subsection{Definition}
An M-edit lens between modules $X$ and $Y$ consists of $\langle C, X \otimes C, Y \otimes C, init_C, K, putr, putl \rangle$. $X \otimes C$ (similarly $Y \otimes C$) is a module $\langle |X| \times C, (init_X, init_C), d(X \otimes C), \cdot_{X \otimes C} \rangle$. $C$ is the type of complement, and $K \subseteq |X| \times C \times |Y|$ is the consistency relation. $X \otimes C$ is a module of edits for the product type $|X| \times C$. The type of $putr$ is $dX \to d(Y \otimes C)$. The type of $putl$ is $dY \to d(X \otimes C)$. $putl$ and $putr$ are (normal) monoid homomorphisms.

\subsection{Lifting on tensor products}
We can lift a module $X$ into a module $lift_C(X)$ of the form $X \otimes C$ as follows. 

$ lift_C(X) \defeq \langle |X| \times C, (init_X, init_C), d(X \otimes C), \cdot_{X \otimes C}$

The monoid of edits of the $lift(X)$ (of type $X \otimes C$) is the same as that of $X$, but the action is different.

$ d(X \otimes C) \defeq dX$

$ dx \cdot_{X \otimes C} (x,c) \defeq (dx \cdot_X x, c) $

Using this, we can lift a lens $l: X \leftrightarrow Y$ as 

$lift_C(l) = \langle l.C \times C, lift_C(X \otimes l.C), lift_C(Y \otimes l.C), (init_{l.C}, init_C), \{ (x,(c,c'),y) \mid (x,c,y) \in K ~\wedge~ c' in C \}, l.putr, l.putl \rangle$ 

\subsection{(Bogus) Composing M-edit lenses}
Given modules $X, Y, Z$, and M-edit lenses $k : X \leftrightarrow Y$ and $l : Y \leftrightarrow Z$, we can define their composition $k;l : X \leftrightarrow Z$ as follows.

$k;l \defeq \langle k.C \times l.C, lift_{l.C}(X \otimes k.C), lift_{k.C}(Z \otimes l.C), (init_{k.C}, init_{l.C}), \\
  \{ (x,(c,c'),z) \mid \exists y. (x,c,y) \in k.K ~\wedge~ (y,c',z) \in l.K\}, putr, putl \rangle$

$putr~dx \defeq l'.putr (k.putr~dx) \textnormal{ where } l' = lift_{k.C}(l)$

$putl~dz \defeq l'.putl (k.putl~dz) \textnormal{ where } l' = lift_{l.C}(k)$

[NB : We are assuming that $\times$ is associative and commutative. We need to insert terms that witness such isomorphisms; presently they are implicit.]

\subsection{M-Edit lens laws}
\begin{mathpar}
  \inferrule*
  {putr~dx = dyc \\ K(x,c,y) \\ dx \cdot x = x' \\ dyc \cdot (y,c) = (y', c')}
  {K(x',c',y')}

  \inferrule*
  {putl~dy = dxc \\ K(x,c,y) \\ dxc \cdot (x,c) = (x', c') \\ dy \cdot y = y'}
  {K(x',c',y')}
 
\end{mathpar}


\subsection{(Bogus) Embedding Edit lenses in M-Edit lenses}
Given an edit lens $l:X \leftrightarrow Y$, we can embed it in an M-edit lens $M(l)$ as follows. 

$M(l) = \langle l.C, X \otimes C, Y \otimes C, init_{l.C}, l.K, id, id \rangle$

$X \otimes C = \langle |X| \times C, (init_X, init_C), dY, \cdot_{X \otimes C} \rangle$

$Y \otimes C = \langle |Y| \times C, (init_Y, init_C), dX, \cdot_{Y \otimes C} \rangle$

$ dx \cdot_{Y \otimes C} (y,c) = (dy \cdot_Y y, c') \textnormal{ where } (dy, c') = l.putr (dx, c)$

$ dy \cdot_{X \otimes C} (x,c) = (dx \cdot_X x, c') \textnormal{ where } (dx, c') = l.putl (dy, c)$

We need to verify the following
\begin{enumerate}
 \item $dx \cdot_{Y \otimes C} (y,c) = (y', c')$ iff $(putr (dx, c) = (dy, c')$ and $dy \cdot_Y y = y')$\\
       This is by definition.
 \item The laws for $M(l)$ imply the laws for $l$.
       This is also by definition. Rewriting the laws for M-lenses using the definitions of $putl$, $putr$, and the monoid actions for $M(l)$ gives us exactly the edit lens laws for $l$.
       
\subsubsection{Bogosity}
  This embedding is bogus because it is not functorial, i.e. $M(k;l) \not\equiv M(k);M(l)$. \comment{Is this really the case? Looks pretty functorial.} 
\end{enumerate}

\subsection{Embedding Edit lenses in M-Edit lenses}

Given an edit lens $l:X \leftrightarrow Y$, we can embed it in an M-edit lens $M(l)$ as follows. 

$M(l) = \langle l.C, X \otimes C, Y \otimes C, init_{l.C}, l.K, putr, putl \rangle$

$X \otimes C = \langle |X| \times C, (init_X, init_C), C \to dY \times C, \cdot_{X \otimes C} \rangle$

$Y \otimes C = \langle |Y| \times C, (init_Y, init_C), C \to dX \times C, \cdot_{Y \otimes C} \rangle$

$ putr~dx = \lambda c \to l.\Rrightarrow (dx, c) $

$ putl~dy = \lambda c \to l.\Lleftarrow (dy, c) $

$ f \cdot_{Y \otimes C} (y,c) = (dy \cdot_Y y, c') \textnormal{ where } (dy, c') = f c$

$ f \cdot_{X \otimes C} (x,c) = (dx \cdot_X x, c') \textnormal{ where } (dx, c') = f c$

We need to verify the following
\begin{enumerate}
 \item $(putr~dx) \cdot_{Y \otimes C} (y,c) = (y', c')$ iff $(\Rrightarrow (dx, c) = (dy, c')$ and $dy \cdot_Y y = y')$\\
       This is by definition.
 \item $M(l)$ is well-behaved if $l$ is well-behaved.
 \item If $M(l)$ is well-behaved, then $l$ is well-behaved. \comment{Does (1) imply this automatically?}
       This is also by definition. Rewriting the laws for M-lenses using the definitions of $putl$, $putr$, and the monoid actions for $M(l)$ gives us exactly the edit lens laws for $l$.
\end{enumerate}

\subsection{Embedding M-Edit lenses in Edit lenses}
Given an M-edit lens $l:X \leftrightarrow Y$, we can embed it in an M-edit lens $E(l)$ as follows. 

$E(l) = \langle (X \times l.C \times Y), (init_X, init_{l.C}, init_Y), putr, putl \rangle $

$putr~(dx, (x,c,y)) = ?$ \comment{Can we do this?}

\subsection{Example M-Edit lens}
  \begin{align*}
    id_X &\in X \leftrightarrow X \\
    C &= () \\
    init &= () \\
    X \otimes () &= \langle X \times (), (init_X, ()), dX, \lambda (dx,(x,())) \to (dx \cdot x, ()) \rangle \\
    K &= \{ (x, (), x) \mid x \in X \} \\
    putr &= id \\
    putl &= id
  \end{align*}
  
Consider the partition lens in Hofmann et al. If we were to enrich the update languages by adding $deleteMin$ to the edit monoid of modules of the form $X^*$, and adding $deleteMinL$, and $deleteMinR$ to the edit monoid of modules of the form $(X \oplus Y)^*$, we can no no longer construct the partition lens with the same complement $\{L,R\}^*$. This is because translating the $deleteMin$ operation would require us to know which element was being deleted so that the complement can be updated. However, since this is not an index-based update, this information is unavailable. Such an edit lens can be constructed if the complement was all of $(X \oplus Y)^*$, but this is inefficient. We can construct an M-edit lens that supports these updates.

  \begin{align*}
    partition &\in (X \oplus Y)^* \leftrightarrow X^* \otimes Y^* \\
    C &= \{L, R\}^* \\
    init &= \epsilon \\
    ~\\
    deleteMinL \cdot_{(X \oplus Y)^*} l &\defeq let~n = findMinL(l)~in~remove~n~l \\
    deleteMinL \cdot_{(X \oplus Y)^*} l &\defeq let~n = findMinR(l)~in~remove~n~l \\
    deleteMinL \cdot (l, c) &\defeq let~n = findMinL(l)~in~(remove~n~l, remove~n~c) \\
    deleteMinR \cdot (l, c) &\defeq let~n = findMinR(l)~in~(remove~n~l, remove~n~c) \\
    left(deleteMin) \cdot_{X^* \otimes Y^*} (l, l') &\defeq let~n = findMin(l)~in~(remove~n~l, l')\\
    right(deleteMin) \cdot_{X^* \otimes Y^*} (l, l') &\defeq let~n = findMin(l)~in~(l, remove~n~l') \\
    left(deleteMin) \cdot ((l, l'), c) &\defeq let~n = findMin(l)~in~((remove~n~l, l'), removeL~n~c) \\
    right(deleteMin) \cdot ((l, l'), c) &\defeq let~n = findMin(l)~in~((l, remove~n~l'), removeR~n~c) \\
    ~\\
    putr~deleteMinL &= left(deleteMin) \\
    putr~deleteMinR &= right(deleteMin) \\
    putl~(left(deleteMin)) &= deleteMinL \\
    putl~(right(deleteMin)) &= deleteMinR \\
  \end{align*}

\section{Converting an M-Edit lens into a pair of (asymmetric) M-Edit lenses}
  \comment{Way in progress}

In the setting of evolution/migration, only one of the two sources (in addition to the complement) is materialized. In such a scenario, it may be efficient to combine the materialized source with the complement to create a 'super-structure', and use (asymmetric) lenses to separately translate between this structure and both sources. 

This may not be viable in alternative settings, particularly in distributed settings, where both sources need to materialized. Alternatively, there may be security concerns that don't allow all the data to be shared.

There seems to be an obvious way to do this for schema evolution in databases. There may not be general way to do this for an arbitrary M-Edit lens.

\section{Comparing edit lenses and m-edit lenses}

\subsection{$term_X$}

\begin{tabular}{ll}
  \begin{minipage}{0.5\linewidth}
    $\begin{aligned}
      term_X &\in X \leftrightarrow \Unit \\
      C &= \Unit \\
      K &= X \times \Unit \times Unit \\
      putr~(dx, ()) &= (id, ()) \\
      putl~(id, ()) &= (id, ())
    \end{aligned}$
  \end{minipage}
  \begin{minipage}{0.5\linewidth}
    $\begin{aligned}
      term_X &\in X \leftrightarrow \Unit \\
      C &= \Unit \\
      K &= X \times Unit \times Unit \\
      putr~dx &= id \\
      putl~id &= id 
    \end{aligned}$
  \end{minipage}
\end{tabular}

\section{Tensor product}

\begin{tabular}{ll}
  \begin{minipage}{0.5\linewidth}
    \begin{mathpar}
      \inferrule*
      {k \in X \leftrightarrow Z \\ l \in Y \leftrightarrow W}
      {k \otimes l \in X \otimes Y \leftrightarrow Z \otimes W}
    \end{mathpar}
    $\begin{array}{lcl}
      C &=& k.C \times l.C \\
      init &=& (k.init, l.init) \\
      K &=& \{ ((x, z), (c_k, c_l), (y,w)) \mid \\
        && \qquad (x, c_k, y) \in k.K \\ 
        && ~\wedge~ (z, c_l, w) \in l.K \}  \\
      \Rrightarrow_g(L(dx), (c_k, c_l)) &=& let~(dz, c_k') = k.\Rrightarrow(dx, c_k) ~in \\
                                    && (L(dz), (c_k', c_l)) \\
      \Rrightarrow_g(R(dy, (c_k, c_l)) &=& let~(dw, c_l') = l.\Rrightarrow(dy, c_l) ~in \\
                                    && (R(dw), (c_k, c_l')) \\
      \Lleftarrow_g \textnormal{ similarly}
      \end{array}$
  \end{minipage}
  \begin{minipage}{0.5\linewidth}
    $\begin{array}{lcl}
      C &=& k.C \times l.C \\
      init &=& (k.init, l.init) \\
      K &=& \{ ((x, z), (c_k, c_l), (y,w)) \mid \\
        && \qquad (x, c_k, y) \in k.K \\ 
        && ~\wedge~ (z, c_l, w) \in l.K \}  \\
      putr~L(dx) &=& L(lift_? (l.putr(dx)) \\
      putr~R(dy) &=& lift_? (r.putr(dy)) \\
      putl~id &= id 
    \end{array}$
  \end{minipage}
\end{tabular}

\section{}

\end{document}
