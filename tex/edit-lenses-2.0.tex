\documentclass[a4paper,10pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{color}
\usepackage{mathpartir}

\newcommand{\finish}[1]{#1}
\newcommand{\comment}[1]{\finish{\textbf{\textcolor{red}{#1}}}}
\newcommand{\jnf}[1]{\finish{\textbf{\textcolor{blue}{[#1---JNF]}}}}
\newcommand{\raghu}[1]{\finish{\textbf{\textcolor{blue}{[#1---Raghu]}}}}

\newcommand{\defeq}{\ensuremath{\stackrel{\Delta}{=}}}

%opening
\title{}
\author{}

\begin{document}

\maketitle

\section{Edit lenses with modifiable complement, aka M-Edit Lenses}
An edit lens between modules X and Y is $\langle C, init_C, K, putr, putl \rangle$. \\
The type of $putr$, $dX \times C \to dY \times C$ can be expressed as the isomorphic type $(dX \times C \to dY, dX \to C \to C)$. Thus, we can view the $putr$ function as having two components; one that translates an edit on $X$ into an edit on $Y$ (using $Y$-data from the complement), and another that updates the complement (its $X$-data) with respect to the edit on $X$.

[NB: We can view data as being $X$-data, $Y$-data, shared data, or alignment data. By $X$-data, we mean data that is present \emph{solely} in $X$ and not in $Y$, and similarly $Y$-data. An example of alignment data is a mapping of indices between two lists. The collection of $X$-indices can be considered $X$-data (and similarly for $Y$), but the mapping itself depends on both. This isn't shared data as it is not data that is present in both $X$ and $Y$ separately.]

For a symmetric lens, the complement represents the data that is not shared. In an edit lens, there is may be no necessity to capture all this data. For example, if we consider a list-mapping edit lens where the updates are list reorderings, the complement could just be $()$. 

Alternatively, let us compare symmetric and edit lenses between $A \times D$ and $A \times E$, where updates include a filter operation. The complement for the symmetric lens would be $D \times E$. 
The complement for the edit lens needs to be $A \times D \times E$; this is because we need to write the transformation $d(A \times D) \to C \to C$, and doing so requires access to the data in $A$. If the complement were just $D \times E$, an update $filter~on~A=a$ cannot be processed , as there is insufficient information to know which elements get filtered.
Thus, for a sufficiently rich set of updates, the complement often subsumes the entirety of the data in the two sources.
[This does not arise in Hofmann et. al.'s paper, as the monoids of edits they consider are not rich enough.]

Even if we assume the complement is rich enough and contains all the needed information then large updates which updates filtered data will result in the constuction of very large edit. For example, consider the case of a database update in which a column is deleted from the table. We construct an edit lens $dA \times C -> dB \times C$. Assuming the richness of the complement we store the whole table in the complement. Now assume an update to $A$ which deletes records based on some predicate on the deleted column. This update can not be directly translated to $dB$ as B does not have the deleted column. So first a filter is applied on the complement to find out the records to be deleted and then those are embedded in the edit $dB$, which results in size of edit to be as large as the number of records in the table.

Ideally, the complement update part of the $putr$ transformation would have the type $(dX, X) \to C \to C$. The changes to the $X$-related components of $C$ can be calcluated from the first argument, and the remainder of $C$ can be propagated from the second argument. 

The complement must contain all the alignment data, since it doesn't exist anywhere else. If the complement contains all the $X$-data, then the complement update part of $putr$ could have its type replaced with $(dX, Y) \to C \to C$, since the shared data is contained in both $X$ and $Y$. The reason for wanting to do this is that $Y$ may be materialized, while $X$ may not. 
In the case of schema evolution, we want to translate $V1$ updates to a $V2$ database, where $V2$ is materialized, and $V1$ is not.

\section{M-Edit lens}

\subsection{Definition}
An M-edit lens between modules $X$ and $Y$ consists of $\langle C, X \otimes C, Y \otimes C, init_C, K, putr, putl \rangle$. $X \otimes C$ (similarly $Y \otimes C$) is a module $\langle |X| \times C, (init_X, init_C), d(X \otimes C), \cdot_{X \otimes C} \rangle$. The type of $putr$ is $dX \to d(Y \otimes C)$. The type of $putl$ is $dY \to d(Y \otimes C)$. $putl$ and $putr$ are monoid homomorphisms.

\subsection{Lifting on tensor products}
We can lift a module $X$ into a module $lift_C(X)$ of the form $X \otimes C$ as follows. 

$ d(X \otimes C) \defeq dX$

$ dx \cdot_{X \otimes C} (x,c) \defeq (dx \cdot_X x, c) $

The monoid of edits of the $lift(X)$ (of type $X \otimes C$) is the same as that of $X$, but the action is different.

In this way, we can lift a lens $l: X \leftrightarrow Y$ as $lift_C(l) = \langle l.C \times C, lift_C(X \otimes C), lift_C(Y \otimes C), (init_{l.C}, init_C), K \times C, l.putr, l.putl \rangle$ 

\subsection{Composing M-edit lenses}
Given modules $X, Y, Z$, and M-edit lenses $k : X \leftrightarrow Y$ and $l : Y \leftrightarrow Z$, we can define their composition $k;l : X \leftrightarrow Z$ as follows.

$k;l \defeq \langle k.C \times l.C, lift_{l.C}(X \otimes k.C), lift_{k.C}(Z \otimes l.C), (init_{k.C}, init_{l.C}), k.K \circ l.K, putr, putl \rangle$

$putr~dx \defeq l'.putr (k.putr~dx) \textnormal{ where } l' = lift_{k.C}(l)$

$putl~dz \defeq l'.putl (k.putl~dz) \textnormal{ where } l' = lift_{l.C}(k)$

[NB : We are assuming that $\times$ is associative and commutative. We need to insert terms that witness such isomorphisms; presently they are implicit.]

\subsection{M-Edit lens laws}
\begin{mathpar}
  \inferrule*
  {putr~dx = dyc \\ K(x,c,y) \\ dx \cdot x = x' \\ dyc \cdot (y,c) = (y', c')}
  {K(x',c',y')}

  \inferrule*
  {putl~dy = dxc \\ K(x,c,y) \\ dxc \cdot (x,c) = (x', c') \\ dy \cdot y = y'}
  {K(x',c',y')}
 
\end{mathpar}


\subsection{Embedding Edit lenses in M-Edit lenses}
Given an edit lens $l:X \leftrightarrow Y$, we can embed it in an M-edit lens $M(l)$ as follows. 

$M(l) = \langle l.C, X \otimes C, Y \otimes C, l.init_C, l.K, id, id \rangle$

$X \otimes C = \langle |X| \times C, (X.init, C.init), dY, \cdot_{X \otimes C} \rangle$

$Y \otimes C = \langle |Y| \times C, (Y.init, C.init), dX, \cdot_{Y \otimes C} \rangle$

$ dx \cdot_{Y \otimes C} (y,c) = (dy \cdot_Y y, c') \textnormal{ where } (dy, c') = l.putr (dx, c)$

$ dy \cdot_{X \otimes C} (x,c) = (dx \cdot_X x, c') \textnormal{ where } (dx, c') = l.putl (dy, c)$

We need to verify the following
\begin{enumerate}
 \item $dx \cdot_{Y \otimes C} (y,c) = (y', c')$ iff $(putr (dx, c) = (dy, c')$ and $dy \cdot_Y y = y')$\\
       This is by definition.
 \item The laws for $M(l)$ imply the laws for $l$.
       This is also by definition. Rewriting the laws for M-lenses using the definitions of $putl$, $putr$, and the monoid actions for $M(l)$ gives us exactly the lens laws for $l$.
\end{enumerate}

\subsection{Embedding M-Edit lenses in Edit lenses}
Given an M-edit lens $l:X \leftrightarrow Y$, we can embed it in an M-edit lens $E(l)$ as follows. 

$E(l) = \langle (X \times l.C \times Y), (init_X, init_{l.C}, init_Y), putr, putl \rangle $

$putr~(dx, (x,c,y)) = ?$ \comment{Can we do this?}


\subsection{Example M-Edit lens}
  \begin{align*}
    id_X &\in X \leftrightarrow X \\
    C &= () \\
    init &= () \\
    X \otimes () &= \langle X \times (), (init_X, ()), dX, \lambda (dx,(x,())) \to (dx \cdot x, ()) \rangle \\
    K &= \{ (x, (), x) \mid x \in X \} \\
    putr &= id \\
    putl &= id
  \end{align*}
  
Consider the partition lens in Hofmann et al. If we were to enrich the update languages by adding $deleteMin$ to the edit monoid of modules of the form $X^*$, and adding $deleteMinL$, and $deleteMinR$ to the edit monoid of modules of the form $(X \oplus Y)^*$, we can no no longer construct the partition lens with the same complement $\{L,R\}^*$. This is because translating the $deleteMin$ operation would require us to know which element was being deleted so that the complement can be updated. However, since this is not an index-based update, this information is unavailable. Such an edit lens can be constructed if the complement was all of $(X \oplus Y)^*$, but this is inefficient. We can construct an M-edit lens that supports these updates.

  \begin{align*}
    partition &\in (X \oplus Y)^* \leftrightarrow X^* \otimes Y^* \\
    C &= \{L, R\}^* \\
    init &= \epsilon \\
    ~\\
    deleteMinL \cdot_{(X \oplus Y)^*} l &\defeq let~n = findMinL(l)~in~remove~n~l \\
    deleteMinL \cdot_{(X \oplus Y)^*} l &\defeq let~n = findMinR(l)~in~remove~n~l \\
    deleteMinL \cdot (l, c) &\defeq let~n = findMinL(l)~in~(remove~n~l, remove~n~c) \\
    deleteMinR \cdot (l, c) &\defeq let~n = findMinR(l)~in~(remove~n~l, remove~n~c) \\
    left(deleteMin) \cdot_{X^* \otimes Y^*} (l, l') &\defeq let~n = findMin(l)~in~(remove~n~l, l')\\
    right(deleteMin) \cdot_{X^* \otimes Y^*} (l, l') &\defeq let~n = findMin(l)~in~(l, remove~n~l') \\
    left(deleteMin) \cdot ((l, l'), c) &\defeq let~n = findMin(l)~in~((remove~n~l, l'), removeL~n~c) \\
    right(deleteMin) \cdot ((l, l'), c) &\defeq let~n = findMin(l)~in~((l, remove~n~l'), removeR~n~c) \\
    ~\\
    putr~deleteMinL &= left(deleteMin) \\
    putr~deleteMinR &= right(deleteMin) \\
    putl~(left(deleteMin)) &= deleteMinL \\
    putl~(right(deleteMin)) &= deleteMinR \\
  \end{align*}

\section{Converting an M-Edit lens into a pair of (asymmetric) M-Edit lenses}
In the setting of evolution/migration, only one of the two sources (in addition to the complement) is materialized. In such a scenario, it may be efficient to combine the materialized source with the complement to create a 'super-structure', and use lenses to separately translate between this structure and both sources. 

This may not be viable in alternative settings, particularly in distributed settings, where both sources need to materialized. Alternatively, there may be security concerns that don't allow sharing all the data.

There may not be a one-size-fits-all way to do this for an arbitrary M-Edit lens.

\end{document}
