\documentclass[a4paper,10pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{fullpage}
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{color}
\usepackage{mathpartir}

\newtheorem{definition}{Definition}
\newtheorem{conj}{Conjecture}
\newtheorem{prop}{Proposition}
\newtheorem{note}{Note}

\newcommand{\finish}[1]{#1}
\newcommand{\comment}[1]{\finish{\textbf{\textcolor{red}{#1}}}}
\newcommand{\jnf}[1]{\finish{\textbf{\textcolor{blue}{[#1---JNF]}}}}
\newcommand{\raghu}[1]{\finish{\textbf{\textcolor{blue}{[#1---Raghu]}}}}

\newcommand{\dcirc}{\ensuremath{\hat{\circ}}}
\newcommand{\defeq}{\ensuremath{\stackrel{\Delta}{=}}}
\newcommand{\Unit}{\ensuremath{\mathbf{Unit}}}
\newcommand{\db}{\ensuremath{\mathbf{DB}}}
\newcommand{\cat}{\ensuremath{\mathbf{cat}}}
\newcommand{\clens}{\ensuremath{\mathbf{CLens}}}
\newcommand{\celens}{\ensuremath{\mathbf{CELens}}}
\newcommand{\letin}[2]{\ensuremath{\textnormal{let}~#1=#2~\textnormal{in}}}
\newcommand{\case}[1]{\ensuremath{\textnormal{case}~#1~\textnormal{of}}}
\newcommand{\where}[2]{\ensuremath{\textnormal{where}~#1=#2}}

%opening
\title{}
\author{}

\input{diagrams.sty}

\begin{document}

\maketitle

\section{Introduction}
\comment{Verbatim copy from previous writeup. Doesn't make much sense
  here without some refactoring}

An edit lens between modules X and Y is $\langle C, init_C, K, putr, putl \rangle$, where $C$ is the type of complement, and $K \subseteq X \times C \times Y$ is the consistency relation. \\
The type of $putr$, $dX \times C \to dY \times C$ can be expressed as
the isomorphic type $(dX \times C \to dY, dX \to C \to C)$. Thus, we
can view the $putr$ function as having two components; one that
translates an edit on $X$ into an edit on $Y$ (using $X$-data from the
complement), and another that updates the complement (its $X$-data and
alignment data) with respect to the edit on $X$.
 
[NB: We can view data as being $X$-data, $Y$-data, shared data, or
alignment data. By $X$-data, we mean data that is present
\emph{solely} in $X$ and not in $Y$, and similarly $Y$-data. An
example of alignment data is a mapping of indices between two
lists. The collection of $X$-indices can be considered $X$-data (and
similarly for $Y$), but the mapping itself depends on both. This isn't
shared data as it is not data that is present in both $X$ and $Y$
separately. An alternative term for alignment data can be
\emph{state}.]

For a symmetric lens, the complement represents the data that is not
shared. In an edit lens, there may be no necessity to capture all this
data. For example, if we consider a list-mapping edit lens where the
updates are list reorderings, the complement could just be \Unit.
 
Alternatively, let us compare symmetric and edit lenses between $A
\times D$ and $A \times E$, where updates include a filter
operation. The complement for the symmetric lens would be $D \times
E$.  The complement for the edit lens needs to be $A \times D \times
E$; this is because we need to write the transformation $d(A \times D)
\to C \to C$, and doing so requires access to the data in $A$. If the
complement were just $D \times E$, an update $filter~on~(A=a)$ cannot
be processed , as there is insufficient information to know which
elements get filtered. Thus, for a sufficiently rich set of updates,
the complement often subsumes the entirety of the data in the two
sources. [This issue does not arise in Hofmann et. al.'s paper, as
the monoids of edits they consider are not rich enough.]

Ideally, the complement update part of the $putr$ transformation would
have the type $(dX, X) \to C \to C$. The changes to the $X$-related
components of $C$ can be calcluated from the first argument, and the
remainder of $C$ can be propagated from the second argument.
 
% The complement must contain all the alignment data, since it doesn't
% exist anywhere else. If the complement contains all the $X$-data, then
% the complement update part of $putr$ could have its type replaced with
% $(dX, Y) \to C \to C$, since the shared data is contained in both $X$
% and $Y$. The reason for wanting to do this is that $Y$ may be
% materialized, while $X$ may not.  In the case of schema evolution, we
% want to translate $V1$ updates to a $V2$ database, where $V2$ is
% materialized, and $V1$ is not.

Even if the complement contains sufficient information, there is still
a problem that the lens may produce very large edits. For example,
consider the case of a database update in which a column is deleted
from a table. This has a corresponding edit lens with a $putr$
function of type $dA \times C \to dB \times C$. If we have an edit
that deletes records depending on whether a predicate holds of the
deleted column, this edit can not be directly translated to an edit on
dB. This is because $B$ does not have the deleted column. Thus, we
first need to apply a filter to the complement to discover which
records will be deleted, and then embed this result in a $dB$
edit. This results in the size of the edit being proportional to the
result of the filter, which can be the entire table in the worst case.

% If we have replaced the complement update part of $putr$ with $(dX, Y)
% \to C \to C$, or more generally, $(dX, Y) \to dC$, then we can combine
% the two components of $putr$ as $dX \to d(Y \times C)$. This solves
% the problem of $putr$ producing a large edit, since the result of the
% computation on $C$ does not need to be embedded in the edit. Instead,
% the computation itself can be expressed in the edit and computed
% later.


\section{Background}

\begin{definition}[Opcartesian Lifting] \label{opcartesian}
  Let $p : I \to X$ be a functor. A morphism $f : A \to B$ in $I$ is opcartesian if for all morphisms $g : A \to C$ in $I$ and $v : pB \to pC$ in $X$ such that $v \cdot pf = pg$, there exists a unique morphism $h : B \to C$ satisfying $h \cdot f = g$
\end{definition}

\begin{figure}[ht]
\begin{displaymath}
\begin{diagram}
    &    &              & C \\
  I &    & \ruTo^g      & \uDashto_h  \\
    & A  & \rTo_f       & B \\
    &    & \dImplies_p  &   \\
    &    & ~            & pC  \\
  X &    & \ruTo^{pg}   & \uTo_v  \\    
    & pA & \rTo_{pf}    & pB  
\end{diagram}
\end{displaymath}
\caption{Opcartesian Lifting}    
\label{fig:opcartesian}
\end{figure}

\begin{definition}[Opfibration] \label{opfibration} 
  A functor $p : I \to X$ is an opfibration if for all morphisms $u :
  pA \to T$ in $X$, there is an opcartesian morphism $f : A \to B$ in
  $I$ such that $pf = u$.
\end{definition}

\begin{note}[Intuition for opcartesian lifting being minimal]
  Let $f : X \to Y$ be the opcartesian lifting of $u$. Let $g : X \to
  Y$ be another morphism such that $pg = u$. Then, $g$ factors through
  $f$. This can be observed (see Figure \ref{fig:intuition}) as a case
  of the opcartesian property where $B = C$ and $v = id$.
\end{note}

\begin{figure}[ht]
\begin{displaymath}
\begin{diagram}
    &    &              & B \\
  I &    & \ruTo^g      & \uDashto_h  \\
    & A  & \rTo_f       & B \\
    &    & \dImplies_p  &   \\
    &    & ~            & pB \\
  X &    & \ruTo^{u = pg}   & \uTo_{v = id}   \\    
    & pA & \rTo_{u = pf}    & pB
\end{diagram}
\end{displaymath}
\caption{Minimality of opcartesian lifting}
\label{fig:intuition}
\end{figure}

\begin{definition}[Pullback]
The pullback (see figure \ref{fig:pullback}) of morphisms $f: X \to C$ and $g: Y \to C$ is defined as
an object $I$ with two morphisms $i_1: I \to X$ and $i_2: I \to Y$
such that 
\begin{enumerate}
\item $f . i_1 = g. i_2$
\item For any other object $Z$ with morphisms $z_1: Z \to X$ and $z_2:
  Z \to Y$ which makes the diagram commute i.e $f. z_1 = g. z_2$ then
  there exists a unique $u$ such that $ i_1 . u = z_1$ and $ i_2 . u = z_2$.
\end{enumerate}
\begin{figure}[ht]
\begin{displaymath}
\begin{diagram}
  Z  &    &    &  & \\
      & \rdDashto^u  \rdTo(4,2)^{z_2} \rdTo(2,4)^{z_1}  &  &  \\
      &    & I               & \rTo^{i_2} & Y \\
      &    & \dTo_{i_1} &                & \dTo^g  \\
      &    & X              & \rTo_f     & C
\end{diagram}
\end{displaymath}
\caption{Pullback}
\label{fig:pullback}
\end{figure}


\end{definition}

\section{C-lenses and CE-lenses}
\begin{definition}[C-lens]
 A c-lens $l$ between categories $I$ and $X$ is an opfibration $l : I \Rightarrow X$.
 [An alternative presentation of c-lenses with lens laws can be found in \cite{jr13}].
\end{definition}

\begin{prop}
 c-lenses form a category \clens, with arbitrary categories as objects and opfibrations as morphisms.
\end{prop}

\begin{definition} [Module]
  A module $X$ is a tuple $\langle |X|, \delta X, \odot_X \rangle$; $|X|$ is a set, $\delta X$ is a monoid, and $\odot_X$ is a partial monoid action of $\delta X$ on $|X|$.
\end{definition}

\paragraph*{Modules as Categories.}
 Every module $X$ gives rise to a category (and thus, an object in $\cat$) as follows. 
\begin {itemize}
\item The objects of the category are the elements $|X|$. 
\item Morphisms in the category are $x \stackrel{dx}{\mapsto} x'$, where $dx \in \delta X$, and $dx \odot x = x'$.
\end{itemize}

\begin{definition}[Equivalence of edits]
Given a module $I$, edits $di_1 \defeq di_2$ if forall $i \in |I|$ $di_1 \circ i = di_2 \circ i$.
\end{definition}
\begin{definition}[CE-lens]
 A ce-lens $l$ between modules $I$ and $X$ consists of the following functions
 \begin{itemize}
  \item $get_0 : I \to X$
  \item $get_1 : dI \times I \to dX$
  \item $put : dX \to dI$
  \comment{The ``obvious type of put would be $dX \times I \to dI$. This type reflects the assumption that $dI$ is rich enough to reflect on $I$}
 \end{itemize}
 satisfying the following laws
 
 \begin{mathpar}
   \inferrule*
     {~}
     {get_1~(id, \_) = id}
     
%    \inferrule*
%      {di \odot i \textnormal{ is undefined}}
%      {get_1 (di, i) \odot (get_0~i) \textnormal{ is undefined}}

   \inferrule*
     {di \odot i = i'}
     {get_1 (di, i) \odot (get_0~i) = get_0~i'  }
        
   \inferrule*
     {~}
     {get_1(di' \circ di, i) = get_1(di', di \cdot i) \circ get_1(di, i)}
   
   \inferrule*
     {~}
     {put~id = id}

   \inferrule*
     {~}
     {get~(put~dx)~i \defeq dx}
   
   \inferrule*
     {~}
     {\exists di' . di \defeq di' \circ put~(get~di~i)}
%    \inferrule*[right=Maybe]
%      {~}
%      {put~dx \odot i = init~(dx \odot (get_0~i))}
   
  \end{mathpar}

\end{definition}

\begin{note} 
  A ce-lens differs from a c-lens in two ways. 
\begin{enumerate}
 \item The $put$ function of a c-lens guarantees a least update, since the lens is an opfibration. The $put$ function of a ce-lens does not guarantee a least update. 
 \comment{What laws do we need to add to ce-lenses to guarantee a least update?}
 
 \item The $put$ function of a c-lens between modules corresponds to a function of the type $dX \times I \to dI$. The type of $put$ in a ce-lens implies that the translation of $dX$ to $dI$ can not depend on the value of $I$. A c-lens does not impose this restriction. In cases where the $put$ function does depend on the value of $I$, the edit monoid $dI$ can be enriched such that the $put$ function no longer needs to depend on $I$.
\end{enumerate}
These differences imply that neither c-lenses nor ce-lenses are a subclass of the other.
\end{note}


\begin{definition}[Identity ce-lens]

\begin{mathpar}
  \inferrule*
    {~}
    {id : A \leftrightarrow A}
  
  \\
  
  \begin{array}{lcl}
    get_0~a     &=& a \\
    get_1~da~\_ &=& da \\
    put~da      &=& da \\
%     init~a      &=& a 
  \end{array}
\end{mathpar}

\end{definition}

\begin{definition}[Composition of ce-lenses]

\begin{mathpar}
  \inferrule*
    {k : A \leftrightarrow B \\ l : B \leftrightarrow C}
    {k;l : A \leftrightarrow C}
  
  \\
  
  \begin{array}{lcl}
    get_0      &=& k.get_0 \circ l.get_0 \\
    get_1~da~a &=& l.get_1~(k.get_1~da~a)~(k.get_0~a) \\
    put        &=& k.put \circ l.put \\
%     init       &=& k.init \circ l.init 
  \end{array}

\end{mathpar}
\end{definition}

\begin{prop}
  ce-lenses form a category, $\celens$, with modules as objects and ce-lenses as morphisms.
\end{prop}

\begin{conj}
  In figure \ref{fig:ce-lens-pullback}, $I$ is the pullback of the diagram consisting of $p_1$ and $p_2$. If $p1$ ($p2$) is a ce-lens, then $q2$ ($q1$) is a ce-lens.
\end{conj}

\begin{figure}[ht]
\begin{displaymath}
\begin{diagram}
  &        &     &       & I &        &     &      &    \\
  &        &     & \ldTo^{q_1} &   & \rdTo^{q_2}  &     &      &    \\ 
  &        & I_1 &       &   &        & I_2 &       &    \\
  &        &     & \rdTo^{p_1} &   & \ldTo^{p_2}  &     &  &    \\
  &        &     &       & Y &        &     &       & 
\end{diagram}
\end{displaymath}
\caption{Pullback of ce-lenses}
\label{fig:ce-lens-pullback}
\end{figure}  

\section{Ideal Lenses}

\comment{TODO: Narrative on how such a lens is constructed and run. What notion of consistency do ideal lenses have/support?}

\begin{definition}
 An ideal lens $l : X \xleftrightarrow{I} Y$ consists of 
 \begin{enumerate}
  \item an ideal $I$ 
  \item Two ce-lenses $l_{\leftarrow} : I \leftrightarrow X$ and $l_{\rightarrow} : I \leftrightarrow Y$
\end{enumerate}
\end{definition}

\section{Composition}
\begin{definition}
The composition of two ideal lenses $l_1: X \xleftrightarrow{I_1} Y$
and $l_2: Y \xleftrightarrow{I_2} Z$ is an ideal lens $l_1;l_2: X
\xleftrightarrow{I} Z$ where $I$ is the pullback of $I_1$ and $I_2$
over $Y$.
\end{definition}

\subsection{Alternate definition of composition}
The composition of two ideal lenses $l_1: X \xleftrightarrow{I_1} Y$
and $l_2: Y \xleftrightarrow{I_2} Z$ under a given ideal lens $l_3:
I_1 \xleftrightarrow{I} I_2$  is an ideal lens $l_1;l_2: X
\xleftrightarrow{I} Z$.

\section{Examples}

\begin{definition}[Terminal lens]
  \begin{mathpar}
    \inferrule*
      {~}
      {term_X \in X \xleftrightarrow{X} \Unit}
  \end{mathpar}
    $term_{X\leftarrow} : X \leftrightarrow X$ is the identity. $term_{X\rightarrow} : X \leftrightarrow \Unit$ is defined by
  \begin{mathpar}
    \begin{array}{lcl}
     get_0~x &=& () \\
     get_1~dx~\_ &=& id \\
     put~du &=& id
    \end{array}
  \end{mathpar}
\end{definition}

\begin{definition}[Tensor product]
  \begin{mathpar}
    \inferrule*
      {k : X \xleftrightarrow{I} Z \\ k : Z \xleftrightarrow{I'} W}
      {k \otimes l \in X \otimes Y \xleftrightarrow{I \otimes I'} Z \otimes W}
  \end{mathpar}
    The monoid of edits for $X \otimes Y$ is $\{(dx, dy) \mid dx \in \delta X, dy \in \delta Y\}$.
    $(k \otimes l)_{\leftarrow} : I \otimes I' \leftrightarrow X \otimes Y$ is defined by
  \begin{mathpar}
    \begin{array}{lcl}
     get_0~(i, i') &=& (k.get_0~I, l.get_0~i') \\
     get_1~(di,di')~(i,i') &=& (k.get_1~di~i, l.get_1~di'~i') \\
     put~(dx, dy) &=& (k.put~dx, l.put~dy)
    \end{array}
  \end{mathpar}
    $(k \otimes l)_{\rightarrow} : I \otimes I' \leftrightarrow Z \otimes W$ is defined similarly.
\end{definition}

\begin{definition}[List mapping]
  \begin{mathpar}
    \inferrule*
      {k : X \xleftrightarrow{I} Y}
      {k^* \in X^* \xleftrightarrow{I^*} Y^*}
  \end{mathpar}
    The monoid of edits for $X^*$ is $\{delete~where~P \mid P \in |X| \to bool\}$. $k^*_{\leftarrow} : I^* \leftrightarrow X^*$ is defined by
%   \begin{mathpar}
%     \begin{array}{lcl}
%      get_0~(is) &=& map~k.get~is \\
%      get_1~(delete~where~P,is) &=& (k.get_1~di~i, l.get_1~di'~i') \\
%      put~(dx, dy) &=& (k.put~dx, l.put~dy)
%     \end{array}
%   \end{mathpar}
%     $(k \otimes l)_{\rightarrow} : I \otimes I' \leftrightarrow Z \otimes W$ is defined similarly.
\end{definition}

\begin{definition}[List mapping for fce-lenses]
  \begin{mathpar}
    \inferrule*
      {k : X \xleftrightarrow{I} Y}
      {k^* \in X^* \xleftrightarrow{I^*} Y^*}
  \end{mathpar}
    $\delta X^* = \{delete~where~P \mid P \in |X| \to bool\} \cup \{delete~n_1, \ldots, n_k \mid n_i \in \mathcal{N}\}$. \\
    $V_{X^*} = |X^*| \cup 2^{\mathcal{N}}$. \\
    $Q_{X^*} = \{filter~P \mid P \in |X| \to bool\} \cup \{\bot\}$. \\
    $filter~P \rhd xs = \{n \mid P(xs!!n)\}$. \\
    $\bot \rhd xs = \{0\}$. \\
    Otherwise, $\rhd$ is undefined.
  \begin{mathpar}
    \begin{array}{lcl}
     get_0~(is) &=& map~k.get~is \\
     fget_1~M~(q,f) &=& (q, \lambda v \to \case{f~v} \\
                     && \quad delete~where~P \to (filter~P, \lambda v' \to delete~v') \\
                     && \quad delete~ns \to (\bot, \lambda \_ \to delete~ns)) \\
     put~(delete~where~P) &=& delete~where~(k.get_0 \circ P) \\
     put~(delete~ns) &=& delete~ns
    \end{array}
   \end{mathpar}
    $(k \otimes l)_{\rightarrow} : I \otimes I' \leftrightarrow Z \otimes W$ is defined similarly.
\end{definition}

\section{Embedding Edit Lenses}
Given an Edit Lens between modules $X$ and $Y$ as $(X,Y,C,init,K,\Rrightarrow,\Lleftarrow)$, an ideal lens between modules $X$ and $Y$ consists of
\begin{enumerate}

\item $I = \langle K, C \to (\delta X, C, \delta Y), \odot_I \rangle$ \\
      $f \odot (x, c, y) = (dx \odot x, c', dy \odot y) \textnormal{ where } (dx, c', dy) = f~c $ 
\item Two ce-lenses $k: I \leftrightarrow X$ and $l : I \leftrightarrow Y$. We show the construction of $k$ here; the construction of $l$ is similar.
  \begin{itemize}
   \item $k.get_0~(x,c,y) = x$
   \item $k.get_1~(f, (x,c,y)) = dx \textnormal{ where } (dx, \_, \_) = f~c$
   \item $k.put~(dx) = \lambda c \to (dx, c', dy) \textnormal{ where } (dy, c') = k.\Rrightarrow(dx, c)$
  \end{itemize}
  
\comment{TODO verify ce-lens laws for k}

\end{enumerate}

\subsection{Alternative embedding}
  \comment{This section proposed an alternative embedding into c-lenses; however, this section doesn't make sense for an embedding into ce-lenses, without additional laws for being an opfibration}
%   We redefine the morphisms of the category $I$ such that for every $(x, dx) \in hom(X)$, $((x,c,y),(dx,dc,dy))$ is an $I$-morphism where $(dy,c') = \Rrightarrow (dx,c)$, $dc = \lambda _ \to c'$.
%   Similarly, for every $(y, dy) \in hom(Y)$, $((x,c,y),(dx,dc,dy))$ is an $I$-morphism where $(dx,c') = \Lleftarrow (dy,c)$, $dc = \lambda _ \to c'$. 
%   
%   The following rule is a sufficient (but not necessary) condition for the lifting to be opcartesian
%   
%   \[ \Rrightarrow (dx,c) = (dy, c') \textnormal{ if and only if } \Lleftarrow (dy, c) = (dx, c') \]
% 
%   The rule, in addition with the definition of $I$-morphisms, implies that there is a unique lifting of $(dx, x)$ [$(dy, y)$] into $I$ for a particular $(x,c,y)$. This is precisely the result of running $\Rrightarrow$ [$\Lleftarrow$]. As a result, the unique morphism from $(x',c',y')$ to $(x'',c'',y'')$ in figure \ref{fig:opcartesian-embedding} is specified by $\Rrightarrow (dx, c')$. The top diagram commutes as a result of $\Rrightarrow$ and $\Lleftarrow$ being stateful homomorphisms.
%   
%   
% \begin{figure}[ht]
% \begin{displaymath}
% \begin{diagram}
%     &    &                         & C \\
%   I &    & \ruTo^{(dx',dc',dy')}   & \uDashto_{(dx'',dc'',dy'')}  \\
%     & A  & \rTo_{(dx,dc,dy)}       & B \\
%     &    & \dImplies_l             &   \\
%     &    & ~                       & pC  \\
%   X &    & \ruTo^{dx'}             & \uTo_{dx''}  \\    
%     & pA & \rTo_{dx}               & pB  
% \end{diagram}
% \end{displaymath}
% \caption{Opcartesian Embedding}    
% \label{fig:opcartesian-embedding}
% \end{figure}  

% \section{Optimizations}
% \begin{enumerate}
%  \item \begin{itemize}
%          \item Can the type of $put$ be $dX \to dI$, where $dX$ and $dI$ are edit monoids (not the set of morphisms)? 
%          \item What laws need to hold for this to be the case?
%          \item Can we construct an algorithm that enriches $dX$ and $dI$ to satisfy the requisite laws?
%        \end{itemize}
%  \item In the scenario where \begin{itemize}
%         \item the ideal is materialized, 
%         \item edit translations are unidirectional $dX \to dI$.
%        \end{itemize} optimizations are simple.
%  \item \begin{itemize}
%         \item Let $l: I \to X$ be an opfibration. We wish to obtain the first element of $X$, where $I$ is materialized. Naively, we translate $I$ to $X$ using the functor, and then get the first element of $X$.
%         \item To do the same without materializing $X$, we need to translate a query $q : X \to V$ that gets the first element of $X$ to $q' : I \to V$ such that $q' = q \circ l$.
%         \item Without the luxury of (1) above, composing two functions $dX \times I \to dI$ and $dI \times \hat{I} \to d\hat{I}$ requires $I$ to be materialized.
%         \item Alternatively, if $I$ and $I'$ are equipped with inter-composable query languages, then these functions become ...
%        \end{itemize}
%  
% \end{enumerate}

\section{Composing $get_1$}
Let us recall the definition of $get_1$ for the composition of two ce-lenses $k : A \leftrightarrow B $ and $l : B \leftrightarrow C$. 
\begin{align*}
 (k;l).get_1~(da,a) &= l.get_1~(k.get_1~(da,a),b) \\
                    & \quad \textnormal{ where } b = (k.get_0~a)
\end{align*}
% 
% \begin{figure}[ht]
% \begin{displaymath}
% \begin{diagram}
%   &        &     &       & I &        &     &      &    \\
%   &        &     & \ldTo^{q_1} &   & \rdTo^{q_2}  &     &      &    \\ 
%   &        & I_1 &       &   &        & I_2 &       &    \\
%   & \ldTo^{p_1}  &     & \rdTo^{p_2} &   & \ldTo^{p_3}  &     & \rdTo^{p_4} &    \\
% X &        &     &       & Y &        &     &       & Z
% \end{diagram}
% \end{displaymath}
% \caption{Composing two lenses}
% \label{fig:db-lenses}
% \end{figure}  

The problem with this naive approach is that $b$ is materialized as an intermediate result, and this may be very large (for example a database). 

We make the observation that $k.get_1$
might not require the whole of $b$ but a relatively miniscule
 part of it (for example, a few  records from the
database). So, to improve upon the existing naive implementation we
propose an alternative approach of using queries to represent the
required parts of the object while transforming edits. 

Another observation we make is that size of the edit produced in the composition above might be quite large, as the values of $a$ and $b$ might be embedded in the edit. In order to limit the complexity
of edits, we permit the presence of queries in edits.

\subsection{Queries}
\begin{definition}[Q-Module] A Q-Module $I$ consists of $(S_I,Q_I,\rhd_I, V_I)$ with
\begin{itemize}
\item $S_I$ is a module
\item $Q_I$ is a monoid of queries
\item $V_I$ is a module $(|V_I|,Q_I,\rhd_I)$
\item $|S_I| \subseteq |V_I|$
\item $\rhd_{I} : Q_I \times |V_I| \rightharpoonup |V_I|$ is a partial monoid action representing the application of a query.

% \item $I_m$ is a module
% \item $Q_I$ is a set of queries
% \item $V_I$ is a module $(|V_I|,Q_I,\rhd_I)$
% \item $|I_m| \subseteq |V_I|$
% \item $\rhd_{I}^{g} : |V_I| \times Q_I \to |V_I|$ is a function which
%   represents action of applying a query
% \item $Q_{I}^*$ is the free monoid of $Q_I$
% \item $\rhd_{I} : |V_I| \times Q_{I}^{*} \to |V_i|$ is defined as
% \begin{align*}
% \rhd_{I}~(v,\epsilon) =~&v \\ 
% \rhd_{I}~(v,q_1,q_2 \ldots q_n) =~&let~v' = \rhd_{I}^{g}~(v,q_1)~in \\
%                                                    &
%                                                    \rhd_{I}~(v',q_2,q_3,
%                                                    \ldots ,q_n)

\end{itemize}
\end{definition} 

\begin{definition}[Liftable Queries]
Given Q-modules $I$ and $X$, and a ce-lens $l : S_I \leftrightarrow S_X$, we say that $Q_X$ can be lifted to $Q_I$ if there exists a function $k : |V_I| \to |V_x|$ such that for all $q_X$ $(\in Q_X)$, there exists a $q_I$ $(\in Q_I)$ such that the diagram (see figure \ref{fig:lifting-queries}) commutes.
\end{definition}

In other words, $Q_X$ is liftable to $Q_I$ if the following functions can be defined - $k_{I \to X}: |V_I|  \to|V_X|$ and $lift_{X \to I}: Q_X \to Q_I$ satisfying the above property. 

\begin{figure}[ht]
\begin{displaymath}
\begin{diagram}
|S_X| & \lTo^{l} & |S_I|\\
\dTo^{q_X } & & \dTo^{q_I} \\
|V_X| & \lTo^{k_{I \to X}} & |V_I| \\
\end{diagram}
\end{displaymath}
\caption{Lifting Queries}
\label{fig:lifting-queries}
\end{figure}
A well-behaved lifting should satisfy the following law

 \begin{mathpar}
   \inferrule*
     {~}
     {lift_{X \to I}~id_{Q_X} = id_{Q_I}}

   \inferrule*
     {~}
     {lift_{X \to I}~(q_1 \circ q_2)~=~lift_{X \to I}~(q_1)~\circ~lift_{X \to I}~(q_2)}
 \end{mathpar}
 
\begin{note}
  We use a dependent sum type in the following sections. The type $\sum\limits_{i \in I} P(i)$ is $\{(i, p) \mid i \in I ~\wedge~ p \in P(i)\}$
\end{note}

\begin{note}
  We extend the use of $\rhd$ to types. $q \rhd I \defeq \{q \rhd i \mid i \in I\}$
\end{note}

\begin{prop}
 If $X$ and $I$ are Q-modules, and $lift_{X \to I}$ is a well-behaved lifting for $k_{I \to X} : |V_I| \to |V_X|$, then the following property holds
 \[
  \inferrule*
   {get_0~i = x}
   {k_{I \to X}~i = x}
 \]

\end{prop}

\begin{definition}[Subqueries]
Given a Q-module $I$, we construct the free monoid of $Q_I$ with subqueries
\begin{itemize}
\item Action is defined as 
\begin{align*}
q~\rhd~(v~\dcirc~f)=(f~(q~\rhd~v))~\rhd~v
\end{align*}
\item For ce-lens $I \leftrightarrow X$, If $Q_X$ can be lifted to $Q_I$ then monoids with subqueries can also be lifted.
\begin{align*}
lift_{X \to I} (q~\dcirc~f)~=~(lift_{X \to I}~q)~\dcirc~(\lambda v \to lift_{X \to I}~(f~(k_{I \to X}~v))
\end{align*}
\end{itemize}
\end{definition}

\subsection{Optimizing edit mapping function composition}

Permitting the presence of queries in edits, we define a
generalization (\comment{Is the use of this word correct}) of $get_1$
for a ce-lens $I \leftrightarrow X$, where $I$ and $X$ are Q-modules:
\[
  fget_1 : \forall \phi. \sum_{q \in Q_\phi} (q \rhd \phi \to \delta I) \to \sum_{q \in Q_\phi} (q \rhd \phi \to \sum_{q' \in Q_I} (q' \rhd I \to \delta X))
\]

where $\phi$ is a Q-module.

A ce-lens with $fget_1$ instead of $get_1$ is called an \emph{fce-lens}. The idea is motivated by the stream fusion paper of having an
intermediate structure to optimize composition.
 \subsubsection{Laws}
  
  \begin{mathpar}
   \inferrule*
     {fget_1~(q,f) = (q',g)}
     {q=q'}
  \end{mathpar}
  
\begin{note}
  This law can probably be enforced by using a more precise (complex?) dependent type.
\end{note}


\subsubsection{Composition}

fce-lenses $k:A \leftrightarrow B$ and $l : B \leftrightarrow C$ can be composed whenever lifting is defined on their query languages.

\begin{mathpar}
  \inferrule*
    {k : A \leftrightarrow B \\ l : B \leftrightarrow C}
    {k;l : A \leftrightarrow C}
  
  \\
  
  \begin{array}{lcl}
    get_0          &=& k.get_0 \circ l.get_0 \\
    fget_1~M~(q,f) &=& \letin{\_, g}{k.fget_1~M~(q,f)} \\
                   && (q, \lambda v. \letin{(q', h)}{g~v} \\
                   && \quad (q' \dcirc (fst \circ d), snd \circ d \circ k_{A \to B} )\\
                   && \quad \where{d}{\lambda v'.} \\
                   && \qquad \letin{\_, j}{l.get~I~(q', h)} \\
                   && \qquad \letin{(q'', p)}{j~v'} \\
                   && \qquad (lift_{B \to A} (q''), p) \\                   
    put            &=& k.put \circ l.put 
  \end{array}

\end{mathpar}  

\subsubsection{Defining  $get_1$ using $fget_1$}
Given $fget_1$ for the above ce-lens, we give a definition of $get_1$
as
\begin{align*}
get_1~(di,i) =~&let~(\_,f) =~fget_1~(id,\lambda~\_~\to di)~in\\
                       &let~(q,g) =~f~i~in \\
                       &g~(q~\rhd~i)
\end{align*}


\comment{Come up with laws for $fget_1$ to such that the above
  embedding satisfies laws for $get_1$.}

\subsection{Optimizing $get_1$ using $fget_1$}
  Composing $get_1$ functions of lenses is expensive, as the intermediate state needs to be materialized. In the case of $fget_1$, only a part of the intermediate state is materialized; the part that is produced by the query returned by $fget_1$.
  
  Using $fget_1$ to optimize composition, we can still expose the $get_1$ interface to the lens-user using the above translation.
  
\section{Models of DB-Lenses}
\comment{Work in progress}

  We propose two models of using ce-lenses for databases; we describe both of them here for comparison.
  
\subsection{Using Q-modules}
\begin{itemize}
\item A database model has three monoids - an edit language $E$, an SMO language $S$, a query language $Q$, and a monoid action $rw : S \times Q \to Q$.
 
\item From the definition of a monoid action, it is the case that $rw~(s \circ s')~q = rw~s~(rw~s'~q)$. In addition, we require that $rw~s~(q \circ q') = (rw~s~q). (rw~s~q')$.
\item The database is a Q-module $(DB,Q,\rhd,V)$.
\item $DB$ is a module $(|DB|,E,\odot)$ where the carrier is set of instances of the database.
\item $|V|$ is at least the closure of $|DB|$ under repeated applications of $Q$.
\item Each element $s$ in $S$ has an ideal-lens $L(s)$ associated with it. For $s_1,s_2 \in S$, $L(s_1 . s_2) ~=~ L(s_1) . L(s_2)$.
\end{itemize}

\subsection{Categorical model}
\begin{itemize}
 \item A database model has three monoids - an edit language $E$, an SMO language $S$, and a query language $Q$, and a monoid action $rw : S \times Q \to Q$.
 
 \item From the definition of a monoid action, it is the case that $rw~(s \circ s')~q = rw~s~(rw~s'~q)$. In addition, we require that $rw~s~(q \circ q') = (rw~s~q). (rw~s~q')$.
 
\item The database model consists of a category $\db$ with two types of objects: source schemas and view schemas. Both source schemas and view schemas are themselves categories. Objects in these categories are schema instances. The homset between a pair of objects in schema categories is a subset of $E$ (applicable edits). A morphism corresponds to the pair of a source object and an edit. Composition of morphisms must respect composition in $E$. 
 
 The homset between a pair of source schemas in $\db$ is a subset of $S$, and between any other pair of objects is a subset of $Q$. Composition of morphisms must respect composition in $Q$ and $S$, as well as the action $rw$. Every morphism in $\db$ (both queries and SMOs) is a ce-lens, i.e. it maps objects and morphisms between the source and target categories.
 
\end{itemize}


\begin{figure}[ht]
\begin{displaymath}
\begin{diagram}
I' & & \\
\dTo^{smo_1} & \rdTo(2,4)^{q_{I'}} & \\
I & &\\
\dTo^{smo_2} & \rdTo^{q_I} & \\
X & \rTo^{q_X} & V
\end{diagram}
\end{displaymath}
\caption{Database Lenses}
\label{fig:database-lens}
\end{figure}


\section{Local Setting}
  In the case where all data is centrally located, it can be more efficient to store the ideal instead of storing several related sources of data. This efficiency comes by way of lower redundancy, and more efficient edit translations. In such a setting, it is unnecessary to support mapping edits to the data sources (using $get_1$), since the sources are virtual. 

  \paragraph*{Optimized translations of edits.}
    The only requirement is to support mapping edits from data sources to the ideal (i.e. $put$), and the definition of ce-lenses is designed to optimize the composition of such edit translations. 
  
\section{Distributed setting}
\comment{TODO}
\begin{figure}[ht]
\begin{displaymath}
\begin{diagram}
 dX & \rTo^X & dCY^-  &              &           &            &
      &             & dX       & \rTo^X  &  X' \\
      &             & dCY^- & \rTo^C  & dY^-   &            &
      &             & dC       & \rTo^C & C' \\
      &             &            &             & dY^-    & \rTo^Y &
      (dY,dC)    &            &  dY       & \rTo^Y & Y' \\
\end{diagram}
\end{displaymath}
\caption{General lens setting}
\label{fig:distributed}
\end{figure}


\section{Questions}
\begin{enumerate}
 \item If in the composition of two lenses we take ideal as the pull back of the two ideals. How do we define the edit language for the new ideal.
\end{enumerate}

\bibliographystyle{plain}
\bibliography{m-and-i-edit-lenses}

\end{document}

