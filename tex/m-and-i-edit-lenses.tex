\documentclass[a4paper,10pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{fullpage}
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{color}
\usepackage{mathpartir}

\newtheorem{definition}{Definition}
\newtheorem{note}{Note}

\newcommand{\finish}[1]{#1}
\newcommand{\comment}[1]{\finish{\textbf{\textcolor{red}{#1}}}}
\newcommand{\jnf}[1]{\finish{\textbf{\textcolor{blue}{[#1---JNF]}}}}
\newcommand{\raghu}[1]{\finish{\textbf{\textcolor{blue}{[#1---Raghu]}}}}

\newcommand{\defeq}{\ensuremath{\stackrel{\Delta}{=}}}
\newcommand{\Unit}{\ensuremath{\mathbf{Unit}}}

%opening
\title{}
\author{}

\input{diagrams.sty}

\begin{document}

\maketitle

\section{Opfibrations}

\begin{definition}[Opcartesian Lifting] \label{opcartesian}
  Let $p : I \to X$ be a functor. A morphism $f : A \to B$ in $I$ is opcartesian if for all morphisms $g : A \to C$ in $I$ and $v : pB \to pC$ in $X$ such that $v \cdot pf = pg$, there exists a unique morphism $h : B \to C$ satisfying $h \cdot f = g$
\end{definition}

\begin{figure}[ht]
\begin{displaymath}
\begin{diagram}
    &    &              & C \\
  I &    & \ruTo^g      & \uDashto_h  \\
    & A  & \rTo_f       & B \\
    &    & \dImplies_p  &   \\
    &    & ~            & pC  \\
  X &    & \ruTo^{pg}   & \uTo_v  \\    
    & pA & \rTo_{pf}    & pB  
\end{diagram}
\end{displaymath}
\caption{Opcartesian Lifting}    
\label{fig:opcartesian}
\end{figure}

\begin{definition}[Opfibration] \label{opfibration} 
  A functor $p : I \to X$ is an opfibration if for all morphisms $u :
  pA \to T$ in $X$, there is an opcartesian morphism $f : A \to B$ in
  $I$ such that $pf = u$.
\end{definition}

\begin{note}[Intuition for opcartesian lifting being minimal]
  Let $f : X \to Y$ be the opcartesian lifting of $u$. Let $g : X \to
  Y$ be another morphism such that $pg = u$. Then, $g$ factors through
  $f$. This can be observed (see Figure \ref{fig:intuition}) as a case
  of the opcartesian property where $B = C$ and $v = id$.
\end{note}

\begin{figure}[ht]
\begin{displaymath}
\begin{diagram}
    &    &              & B \\
  I &    & \ruTo^g      & \uDashto_h  \\
    & A  & \rTo_f       & B \\
    &    & \dImplies_p  &   \\
    &    & ~            & pB \\
  X &    & \ruTo^{u = pg}   & \uTo_{v = id}   \\    
    & pA & \rTo_{u = pf}    & pB
\end{diagram}
\end{displaymath}
\caption{Minimality of opcartesian lifting}
\label{fig:intuition}
\end{figure}

\begin{definition}[Pullback]
The pullback (see figure \ref{fig:pullback}) of morphisms $f: X \to C$ and $g: Y \to C$ is defined as
an object $I$ with two morphisms $i_1: I \to X$ and $i_2: I \to Y$
such that 
\begin{enumerate}
\item $f . i_1 = g. i_2$
\item For any other object $Z$ with morphisms $z_1: Z \to X$ and $z_2:
  Z \to Y$ which makes the diagram commute i.e $f. z_1 = g. z_2$ then
  there exists a unique $u$ such that $ i_1 . u = z_1$ and $ i_2 . u = z_2$.
\end{enumerate}
\begin{figure}[ht]
\begin{displaymath}
\begin{diagram}
  Z  &    &    &  & \\
      & \rdDashto^u  \rdTo(4,2)^{z_2} \rdTo(2,4)^{z_1}  &  &  \\
      &    & I               & \rTo^{i_2} & Y \\
      &    & \dTo_{i_1} &                & \dTo^g  \\
      &    & X              & \rTo_f     & C
\end{diagram}
\end{displaymath}
\caption{Pullback}
\label{fig:pullback}
\end{figure}


\end{definition}
\section{Category-theoretic Model of Database lenses}
\begin{itemize}
 \item A database model has two languages, an edit language
 \item Categories have two types of objects: schemas and views. are types equipped with a monoid of updates. Objects of the category are values, and morphisms between objects are updates corresponding to the monoid action. Thus, the pair of a source object and update corresponds to a single morphism. 
 \item A Symmetric lens between $X$ and $Y$ is a pair of opfibrations (functors) between categories $X$ and $I$, and $Y$ and $I$.
 \item A query is an opfibration from $X$ to $V$.
 \item A query translation is $\ldots$
 %\item A correspondence between two categories is specified by its ``l-diagram''. In the simple case (no state), the l-diagram is just $X \to X \cap Y \leftarrow Y$.
 %\item Every l-diagram has a limit, defined the \emph{ideal}. 
\end{itemize}

\section{C-lens}
\begin{definition}[Categorical]
 An c-lens $l$ between categories $I$ and $X$ is an opfibration $l : I \Rightarrow X$.
\end{definition}

\begin{definition} [\comment{TODO Module}]
 
\end{definition}

\begin{definition}[Concrete]
 An c-lens $l$ between modules $I$ and $X$ consists of the following functions
 \begin{itemize}
  \item $get_0 : I \to X$
  \item $get_1 : dI \times I \rightharpoonup dX$
  \item $put : dX \to dI$
  \item $init : X \to I$
 \end{itemize}
 satisfying the following laws
 \begin{mathpar}
   \inferrule*
     {di \cdot i \textnormal{ is defined}}
     {get_1 (di, i) \textnormal{ is defined}  }
     
  \inferrule*
     {get_0 ~ i = x \\ get_0 ~ i' = x' \\\\
      di \cdot i = i' \\ get_1 (di, i) = dx}
     {dx \cdot x = x'}
 \end{mathpar}
 
 \begin{mathpar}
   \inferrule*
     {~}
     {put~id = id}
     
   \inferrule*
   {~}
   {get_1~(id, \_) = id}
 \end{mathpar}


\end{definition}

\section{Ideal Lenses}
\begin{definition}
 An ideal lens $l : X \xleftrightarrow{I} Y$ consists of 
 \begin{enumerate}
  \item an ideal $I$ 
  \item Two c-lenses $k : I \Rightarrow X$ and $l : I \Rightarrow Y$
\end{enumerate}
\end{definition}

\section{Composition}
\begin{definition}
The composition of two ideal lenses $l_1: X \xleftrightarrow{I_1} Y$
and $l_2: Y \xleftrightarrow{I_2} Z$ is an ideal lens $l_1;l_2: X
\xleftrightarrow{I} Z$ where $I$ is the pullback of $I_1$ and $I_2$
over $Y$.

\begin{itemize}
 \item $I \Rightarrow I_1$ and $I \Rightarrow I_2$ are
  opfibrations
 \item $I \Rightarrow X$ and $I \Rightarrow Z$ are
  opfibrations 
\end{itemize}
  Refer to Ross's yellow book.

\end{definition}

\section{I-lenses in a distributed setting}
\begin{figure}[ht]
\begin{displaymath}
\begin{diagram}
 dX & \rTo^X & dCY^-  &              &           &            &
      &             & dX       & \rTo^X  &  X' \\
      &             & dCY^- & \rTo^C  & dY^-   &            &
      &             & dC       & \rTo^C & C' \\
      &             &            &             & dY^-    & \rTo^Y &
      (dY,dC)    &            &  dY       & \rTo^Y & Y' \\
\end{diagram}
\end{displaymath}
\caption{General lens setting}
\label{fig:distributed}
\end{figure}

\section{Questions}
\begin{enumerate}
 \item Labeled morphisms. $dX \times I \to dI, dI \to dY$ versus $lX \to lI, lI \times I \to lY$.
 \item Composing opfibrations. Can we have a lifting $(I \to dI) \to (I' \to dI')$.
 \item The ideal is not something that is intuitive to a lens designer. Instead, the l-diagram can be a more intuitive thing, from which we can perhaps construct the ideal.
 \item If in the composition of two lenses we take ideal as the pull back of the two ideals. How do we define the edit language for the new ideal.
\end{enumerate}

\section{Embedding Edit Lenses}
Given an Edit Lens between modules $X$ and $Y$ as $(X,Y,C,init,K,\Rrightarrow,\Lleftarrow)$, A semi-ideal lens consists of
\begin{enumerate}
\item $I = K$
\item For a tuple $(x,dx)$ such that $dx \cdot x=x'$ there
  exist a morphism $f_{dx}: x \to x'$ in X. 
\item For a tuple $((x,c,y),(dx,dc,dy))$ such
  that $(dx.x,dc.c,dy.y)=(x',c',y')$ there exist a morphism $f_{(dx,dc,dy)}:
  (x,c,y) \to (x',c',y')$ in I.
\item Ideal c-lens $I \Rightarrow X$ is defined as 

\begin {itemize}
\item Functor $F: I \to X$ 

$F~(x,c,y) = x$ 

$F~((x,c,y),(dx,dc,dy))=(x,dx)$ 
\item A lifting $lift: hom(X) \times I \to hom(I)$ 
      
$lift~(f_{dx},(x,c,y))=let~(dy,c')=\Rrightarrow(dx,c)~in~((dx \cdot x, c', dy \cdot y), (f_{dx},(\lambda
  \_ \to c'),dy))$
\end{itemize}
\item Similarly a c-lens for $I \Rightarrow Y$ can be defined.
\end{enumerate}

\subsection{Making the lifting an opfibration}
  We redefine the morphisms of the category $I$ such that for every $(x, dx) \in hom(X)$, $((x,c,y),(dx,dc,dy))$ is an $I$-morphism where $(dy,c') = \Rrightarrow (dx,c)$, $dc = \lambda _ \to c'$.
  Similarly, for every $(y, dy) \in hom(Y)$, $((x,c,y),(dx,dc,dy))$ is an $I$-morphism where $(dx,c') = \Lleftarrow (dy,c)$, $dc = \lambda _ \to c'$. 
  
  The following rule is a sufficient (but not necessary) condition for the lifting to be opcartesian
  
  \[ \Rrightarrow (dx,c) = (dy, c') \textnormal{ if and only if } \Lleftarrow (dy, c) = (dx, c') \]

  The rule, in addition with the definition of $I$-morphisms, implies that there is a unique lifting of $(dx, x)$ [$(dy, y)$] into $I$ for a particular $(x,c,y)$. This is precisely the result of running $\Rrightarrow$ [$\Lleftarrow$]. As a result, the unique morphism from $(x',c',y')$ to $(x'',c'',y'')$ in figure \ref{fig:opcartesian-embedding} is specified by $\Rrightarrow (dx, c')$. The top diagram commutes as a result of $\Rrightarrow$ and $\Lleftarrow$ being stateful homomorphisms.
  
  
\begin{figure}[ht]
\begin{displaymath}
\begin{diagram}
    &    &                         & C \\
  I &    & \ruTo^{(dx',dc',dy')}   & \uDashto_{(dx'',dc'',dy'')}  \\
    & A  & \rTo_{(dx,dc,dy)}       & B \\
    &    & \dImplies_l             &   \\
    &    & ~                       & pC  \\
  X &    & \ruTo^{dx'}             & \uTo_{dx''}  \\    
    & pA & \rTo_{dx}               & pB  
\end{diagram}
\end{displaymath}
\caption{Opcartesian Embedding}    
\label{fig:opcartesian-embedding}
\end{figure}  

\section{Optimizations}
\begin{enumerate}
 \item \begin{itemize}
         \item Can the type of $put$ be $dX \to dI$, where $dX$ and $dI$ are edit monoids (not the set of morphisms)? 
         \item What laws need to hold for this to be the case?
         \item Can we construct an algorithm that enriches $dX$ and $dI$ to satisfy the requisite laws?
       \end{itemize}
 \item In the scenario where \begin{itemize}
        \item the ideal is materialized, 
        \item edit translations are unidirectional $dX \to dI$.
       \end{itemize} optimizations are simple.
 \item \begin{itemize}
        \item Let $l: I \to X$ be an opfibration. We wish to obtain the first element of $X$, where $I$ is materialized. Naively, we translate $I$ to $X$ using the functor, and then get the first element of $X$.
        \item To do the same without materializing $X$, we need to translate a query $q : X \to V$ that gets the first element of $X$ to $q' : I \to V$ such that $q' = q \circ l$.
        \item Without the luxury of (1) above, composing two functions $dX \times I \to dI$ and $dI \times \hat{I} \to d\hat{I}$ requires $I$ to be materialized.
        \item Alternatively, if $I$ and $I'$ are equipped with inter-composable query languages, then these functions become ...
       \end{itemize}
 
\end{enumerate}

\section{Local Setting}
We specialize the opcartesian lifting for the local setting to have
optimized composition. The opcartesian lifting for functor $p: I
\Rightarrow X$ is denoted by existence of the lifting function $f_X
\times I \to f_I$ which when written in terms of the labels is $d_X
\times I \to d_I$. 

Under the special case when the lifting does not require $I$ the
lifting function reduces to $d_X \to d_I$. We propose that even when
this is not the case $d_I$ can be enriched to allow the above
specialized lifting.

\subsection{Model}
In the local setting when ideal acts as the centralized store and all
the views are just functor mapping on the ideal. So an update on any
view can be propogated to the ideal of the lens through the above
lifting. The ideal and hence the associated views can thus be updated.

\begin{figure}[ht]
\begin{displaymath}
\begin{diagram}
  &       & I &   &  \\
  & \ldTo & & \rdTo & \\
X & & & & Y      \\
  &       & dI  & & \\
  & \ruTo & & \luTo \\
dX & & & & dY
\end{diagram}
\end{displaymath}
\caption{Model}
\label{fig:db-lens}
\end{figure}  

\subsection{Composing Opfibrations}
The optimized composition in the local setting only require
propogating updates up the lens. So for example (see figure
\ref{fig:db-lenses}) in the composition of lenses $l_1: X \to Y$ and
$l_2: Y \to Z$, edit $dX$ will be propogated to $dI$ through $dI_1$
where it is applied to $I$. 
%% This does not require propogating the
%% updates down to $dY$ or $dZ$ as they are virtual views of $I$ and are
%% automatically updated as $I$ is updated through $dI$.

\begin{figure}[ht]
\begin{displaymath}
\begin{diagram}
  &        &     &       & I &        &     &      &    \\
  &        &     & \ldTo^{q_1} &   & \rdTo^{q_2}  &     &      &    \\ 
  &        & I_1 &       &   &        & I_2 &       &    \\
  & \ldTo^{p_1}  &     & \rdTo^{p_2} &   & \ldTo^{p_3}  &     & \rdTo^{p_4} &    \\
X &        &     &       & Y &        &     &       & Z
\end{diagram}
\end{displaymath}
\caption{Composing two lenses}
\label{fig:db-lenses}
\end{figure}  
  
\section{Composing Functors}
The functor gives the function $f_I \to f_x$ which while writing in
terms of edit transforms to $d_I \times I \to d_X$. Now if we look at
the previous example of composing two lenses (see figure
\ref{fig:db-lenses}), given the functors $q: I \to I_2$ and $p: I_2
\to Z$, we need to construct their composition $s$. We represent
functor as two functions, one mapping objects and other mapping
morphisms (or edits in our case). Function for mapping objects ($s_e$)
is an obvious composition. So we need to constuct function mapping
edits, $s_e: d_I \times I \to dZ$ from $q_{e}: d_I \times I \to
d_{I_2}$ and $p_{e}: d_{I_2} \times I_2 \to d_Z$. Now the obvious
implementation of the composition is
\begin{align*}
s_e~(d_i,i) =~& let~d_{i_2} = q_{e}~(d_i,i) \\
                 & let~i_2 = q_{o}~(i) \\
                 & p_{e}~(d_{i_2},i_2) 
\end{align*}

The problem with this naive approach is $get$ ($q_{o}$) operation is
very costly when $i_2$ is very large (for example a database). 

The observation we make is the edit mapping function ($p_{e}$)
might not require the whole of $i_2$ but only parts of it which can be
very small as compared to $i_2$ (for example, few records from the
database). So, to improve upon the existing naive implementation we
propose an alternative approach of using queries to represent the
required parts of the object while transforming edits.

Another observation we make is that the edit $d_{i_2}$ might be quite large, as
the values of $I$ might be embedded in $d_{i_2}$. In order to limit the complexity
of edits, we permit the presence of queries in edits.

\subsection{Queries and Lifting Queries}
\comment{TODO}

\subsection{Optimizing edit mapping function composition}
The new type of put function (for functor $p: I \to X$) we propose is
\begin{align*}
\forall \phi. (q_{\phi}, V \to d_I) \to ((q_{\phi},q_I), (V,V') \to dX) 
\end{align*}

\comment{TODO: Show composition can be done easily using lift} 
\end{document}

